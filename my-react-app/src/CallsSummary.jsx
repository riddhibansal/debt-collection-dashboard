/*import React, { useEffect, useMemo, useState } from "react";
import Papa from "papaparse";
import _ from 'lodash'; // ADDED LODASH IMPORT

// ==========================================================
// HELPER FUNCTIONS
// ==========================================================

// Simple common English stop words for filtering
const STOP_WORDS = [
  "the", "a", "an", "and", "or", "but", "in", "on", "at", "to", 
  "for", "of", "is", "was", "be", "it", "that", "this", "have", "with",
];

// Extracts keywords from text: removes punctuation, converts to lower case, filters stop words, and filters short words
function extractKeywords(text) {
  if (typeof text !== "string") return [];
  return text.toLowerCase()
    .replace(/[^\w\s]/g, ' ') // Replace punctuation with space
    .split(/\s+/)            // Split by one or more spaces
    .filter(word => word.length > 3 && !STOP_WORDS.includes(word));
}

// Counts keyword frequency across an array of keyword arrays
const countKeywordFrequency = (keywordArrays) => {
  const wordCounts = {};
  keywordArrays.forEach(keywords => {
    keywords.forEach(word => {
      wordCounts[word] = (wordCounts[word] || 0) + 1;
    });
  });
  
  // Convert to array and sort by frequency (descending)
  return Object.entries(wordCounts)
    .sort(([, countA], [, countB]) => countB - countA)
    .map(([word, count]) => ({ word, count }));
};

// Turn "HH:MM:SS" into total seconds
function parseHMS(hms) {
  if (!hms || typeof hms !== "string") return 0;
  const parts = hms.split(":").map(Number);
  if (parts.length === 3) {
    const [hh, mm, ss] = parts;
    if ([hh, mm, ss].some(Number.isNaN)) return 0;
    return hh * 3600 + mm * 60 + ss;
  } else if (parts.length === 2) {
    const [mm, ss] = parts;
    if ([mm, ss].some(Number.isNaN)) return 0;
    return mm * 60 + ss;
  } else if (parts.length === 1 && !Number.isNaN(parts[0])) {
    return parts[0];
  }
  return 0;
}

// Turn seconds back into "HH:MM:SS"
function formatSecondsToHMS(totalSeconds) {
  const pad = (n) => String(n).padStart(2, "0");
  const s = Math.max(0, Math.floor(totalSeconds || 0));
  const hh = Math.floor(s / 3600);
  const mm = Math.floor((s % 3600) / 60);
  const ss = s % 60;
  return pad(hh) + ":" + pad(mm) + ":" + pad(ss);
}

// Convert "HH:MM:SS" to total minutes (rounded to 2 decimal places)
function hmsToMinutes(hms) {
  if (typeof hms !== "string") return 0;
  const parts = hms.split(":");
  const h = parseInt(parts[0], 10) || 0;
  const m = parseInt(parts[1], 10) || 0;
  const s = parseInt(parts[2], 10) || 0;
  
  const totalSeconds = h * 3600 + m * 60 + s;
  return Math.round((totalSeconds / 60) * 100) / 100;
}

// Categorize duration
function categorizeDuration(minutes) {
  if (minutes < 2) return "Short";
  if (minutes <= 5) return "Medium";
  return "Long";
}

// Normalize boolean values
function toBool(v) {
  if (v === true || v === false) return v;
  const s = String(v || "").trim().toLowerCase();
  return s === "y" || s === "yes" || s === "true" || s === "1";
}

// Extract hour from time string (assuming HH:MM:SS)
function extractHour(timeStr) {
  if (typeof timeStr !== 'string') return 0;
  const timeParts = timeStr.split(':');
  // Returns 0 if parsing fails, which acts as an 'Unknown' hour bin
  return parseInt(timeParts[0], 10) || 0; 
}

// StatCard component
function StatCard({ label, value }) {
  return (
    <div
      style={{
        border: "1px solid #eee",
        borderRadius: 8,
        padding: 12,
        background: "white",
        boxShadow: "0 1px 2px rgba(0,0,0,0.03)",
        color: "#333",
      }}
    >
      <div style={{ fontSize: 12, color: "#666", marginBottom: 6 }}>
        {label}
      </div>
      <div style={{ fontSize: 18, fontWeight: 600 }}>{value}</div>
    </div>
  );
}

// ==========================================================
// MAIN COMPONENT
// ==========================================================

export default function CallsSummary() {
  const [rows, setRows] = useState([]);
  const [loading, setLoading] = useState(true);
  const [errorMsg, setErrorMsg] = useState("");

  useEffect(() => {
    setLoading(true);
    setErrorMsg("");
    Papa.parse("./riddhiproject.csv", {
      header: true,
      download: true,
      skipEmptyLines: true,
      dynamicTyping: false,
      complete: (results) => {
        setRows(results.data || []);
        setLoading(false);
      },
      error: (err) => {
        setErrorMsg(err?.message || "Failed to load CSV");
        setLoading(false);
      },
    });
  }, []);

  const stats = useMemo(() => {
    if (!rows.length) {
      return {
        total: 0,
        avgHMS: "00:00:00",
        ptpCounts: { true: 0, false: 0 },
        rtpCounts: { true: 0, false: 0 },
        escCounts: { true: 0, false: 0 },
        successRate: 0,
        escalationRate: 0,
        durationCategoryCounts: { Short: 0, Medium: 0, Long: 0 },
        topKeywordsEscalated: [],
        topKeywordsNonEscalated: [],
        successRateByHour: [], // ADDED
        escalationRateByDuration: [], // ADDED
        avgDurationByPtpStatus: [], // ADDED
      };
    }

    // ==========================================================
    // FEATURE ENGINEERING & DATA TRANSFORMATION
    // ==========================================================
    const processedRows = rows.map((row) => {
      const durationMinutes = hmsToMinutes(row.call_duration);
      const durationCategory = categorizeDuration(durationMinutes);
      const attemptHour = extractHour(row.attempt_time); // RE-ADDED attempt_hour

      return {
        ...row,
        call_duration_minutes: durationMinutes,
        duration_category: durationCategory,
        attempt_hour: attemptHour, // Added to row
        is_ptp: toBool(row.ptp), // Added for lodash filtering
        is_escalated: toBool(row.escalation), // Added for lodash filtering
        keywords: extractKeywords(row.call_summary), 
      };
    });
    // ==========================================================
    
    // STATS CALCULATION using processedRows
    const total = processedRows.length;
    
    // Average duration
    const secs = processedRows.map((r) => parseHMS(r.call_duration));
    const sumSecs = secs.reduce((a, b) => a + (Number.isFinite(b) ? b : 0), 0);
    const avgSecs = total > 0 ? sumSecs / total : 0;
    const avgHMS = formatSecondsToHMS(avgSecs);

    // Boolean distributions
    const ptpBools = processedRows.map((r) => r.is_ptp); // Use processed bool
    const rtpBools = processedRows.map((r) => r.rtp);
    const escBools = processedRows.map((r) => r.is_escalated); // Use processed bool

    const countTrueFalse = (arr) => ({
      true: arr.filter(Boolean).length,
      false: arr.filter((x) => !x).length,
    });
    
    // Helper to count category occurrences
    const countCategories = (arr) => arr.reduce((acc, val) => {
        acc[val] = (acc[val] || 0) + 1;
        return acc;
    }, { Short: 0, Medium: 0, Long: 0 });

    const ptpCounts = countTrueFalse(ptpBools);
    const rtpCounts = countTrueFalse(rtpBools);
    const escCounts = countTrueFalse(escBools);

    // New Statistic
    const durationCategoryCounts = countCategories(processedRows.map(r => r.duration_category));

    // Rates
    const successRate = total ? (ptpCounts.true / total) * 100 : 0;
    const escalationRate = total ? (escCounts.true / total) * 100 : 0;

    // ==========================================================
    // TEXT ANALYSIS (Existing)
    // ==========================================================
    const escalatedCalls = processedRows.filter(r => r.is_escalated);
    const nonEscalatedCalls = processedRows.filter(r => !r.is_escalated);

    const keywordsEscalated = escalatedCalls.map(r => r.keywords);
    const keywordsNonEscalated = nonEscalatedCalls.map(r => r.keywords);

    const topKeywordsEscalated = countKeywordFrequency(keywordsEscalated).slice(0, 10);
    const topKeywordsNonEscalated = countKeywordFrequency(keywordsNonEscalated).slice(0, 10);

    // ==========================================================
    // 4. BASIC STATISTICAL ANALYSIS (NEW)
    // ==========================================================

    // 1. Success rate by time of day
    const successRateByHour = _.chain(processedRows)
      .groupBy('attempt_hour')
      .map((calls, hour) => ({
        hour: parseInt(hour, 10),
        successRate: (_.filter(calls, { is_ptp: true }).length / calls.length) * 100,
        totalCalls: calls.length
      }))
      .sortBy('hour')
      .value();

    // 2. Escalation rate by call duration category
    const escalationRateByDuration = _.chain(processedRows)
      .groupBy('duration_category')
      .map((calls, category) => ({
        category: category,
        escalationRate: (_.filter(calls, { is_escalated: true }).length / calls.length) * 100,
        totalCalls: calls.length
      }))
      .value();

    // 3. Average duration by PTP status
    const avgDurationByPtpStatus = _.chain(processedRows)
      .groupBy('is_ptp')
      .map((calls, isPtp) => ({
        ptpStatus: isPtp === 'true' ? 'PTP Captured' : 'No PTP',
        avgDurationMinutes: _.sumBy(calls, 'call_duration_minutes') / calls.length,
        totalCalls: calls.length
      }))
      .value();


    return {
      total,
      avgHMS,
      ptpCounts,
      rtpCounts,
      escCounts,
      successRate,
      escalationRate,
      durationCategoryCounts,
      topKeywordsEscalated,
      topKeywordsNonEscalated,
      successRateByHour, // ADDED
      escalationRateByDuration, // ADDED
      avgDurationByPtpStatus, // ADDED
    };
  }, [rows]); 


  if (loading) {
    return (
      <div style={{ padding: 16, background: "#212121", color: "white" }}>
        Loading CSVâ€¦
      </div>
    );
  }
  if (errorMsg) {
    return (
      <div style={{ padding: 16, color: "crimson", background: "#212121" }}>
        Error: {errorMsg}
      </div>
    );
  }

  // ==========================================================
  // JSX RENDERING (OUTPUT)
  // ==========================================================
  return (
    <div
      style={{
        padding: 16,
        fontFamily: "system-ui, -apple-system, Segoe UI, Roboto, sans-serif",
        background: "#212121",
        color: "white",
      }}
    >
      <h2 style={{ marginTop: 0 }}>Calls Summary</h2>

      {/* Basic Stat Cards */ /*}
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))",
          gap: 12,
        }}
      >
        <StatCard label="Total Calls" value={stats.total} />
        <StatCard label="Average Call Duration" value={stats.avgHMS} />
        <StatCard
          label="PTP: True / False"
          value={String(stats.ptpCounts.true) + " / " + String(stats.ptpCounts.false)}
        />
        <StatCard
          label="RTP: True / False"
          value={String(stats.rtpCounts.true) + " / " + String(stats.rtpCounts.false)}
        />
        <StatCard
          label="Escalations: True / False"
          value={String(stats.escCounts.true) + " / " + String(stats.escCounts.false)}
        />
        <StatCard
          label="Success Rate (PTP %)"
          value={stats.successRate.toFixed(1) + "%"}
        />
        <StatCard
          label="Escalation Rate (%)"
          value={stats.escalationRate.toFixed(1) + "%"}
        />
        {/* Duration Stats */ /*}
        <StatCard
          label="Short Calls (< 2 min)"
          value={stats.durationCategoryCounts.Short}
        />
        <StatCard
          label="Medium Calls (2-5 min)"
          value={stats.durationCategoryCounts.Medium}
        />
        <StatCard
          label="Long Calls (> 5 min)"
          value={stats.durationCategoryCounts.Long}
        />
      </div>

      <h3 style={{ marginTop: 32 }}>Basic Statistical Analysis</h3>
      <div style={{ 
          display: "grid", 
          gridTemplateColumns: "repeat(auto-fit, minmax(300px, 1fr))", 
          gap: 16 
        }}>
        <AnalysisBox title="Success Rate by Hour of Day" data={stats.successRateByHour} />
        <AnalysisBox title="Escalation Rate by Duration Category" data={stats.escalationRateByDuration} />
        <AnalysisBox title="Average Duration by PTP Status" data={stats.avgDurationByPtpStatus} />
      </div>


      {/* Text Analysis Output */ /*}
      <h3 style={{ marginTop: 32 }}>Call Summary Keyword Analysis</h3>
      <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 }}>
        <KeywordList 
          title="Top 10 Keywords in ESCALATED Calls" 
          keywords={stats.topKeywordsEscalated} 
          isEscalated={true} 
        />
        <KeywordList 
          title="Top 10 Keywords in NON-ESCALATED Calls" 
          keywords={stats.topKeywordsNonEscalated} 
          isEscalated={false} 
        />
      </div>


      {/* Sample Rows */ /*}
      <h3 style={{ marginTop: 24 }}>Sample Rows</h3>
      <div style={{ fontSize: 12, color: "#999", marginBottom: 8 }}>
        Showing the first 5 rows so you can confirm columns look right.
      </div>
      <table
        style={{
          width: "100%",
          borderCollapse: "collapse",
          textAlign: "left",
          color: "white",
        }}
      >
        <thead>
          <tr style={{ backgroundColor: "#424242" }}>
            <th style={{ padding: "8px" }}>customer_id</th>
            <th style={{ padding: "8px" }}>ptp</th>
            <th style={{ padding: "8px" }}>rtp</th>
            <th style={{ padding: "8px" }}>call_duration</th>
            <th style={{ padding: "8px" }}>escalation</th>
            <th style={{ padding: "8px" }}>Minutes</th>
            <th style={{ padding: "8px" }}>Category</th>
          </tr>
        </thead>
        <tbody>
          {rows.slice(0, 5).map((r, idx) => {
            const durationMinutes = hmsToMinutes(r.call_duration);
            const durationCategory = categorizeDuration(durationMinutes);
            
            return (
              <tr
                key={idx}
                style={{
                  borderBottom: "1px solid #666",
                  backgroundColor: idx % 2 === 0 ? "#303030" : "#212121",
                }}
              >
                <td style={{ padding: "8px" }}>{r.customer_id}</td>
                <td style={{ padding: "8px" }}>{String(r.ptp)}</td>
                <td style={{ padding: "8px" }}>{String(r.rtp)}</td>
                <td style={{ padding: "8px" }}>{r.call_duration}</td>
                <td style={{ padding: "8px" }}>{String(r.escalation)}</td>
                <td style={{ padding: "8px" }}>{durationMinutes.toFixed(2)}</td>
                <td style={{ padding: "8px" }}>{durationCategory}</td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
}

// ==========================================================
// NEW COMPONENTS FOR DISPLAY
// ==========================================================

// Keyword List Component (moved here for cleaner main component)
function KeywordList({ title, keywords }) {
  const isTrigger = (word) => ["fraud", "paid", "issue", "refund", "complaint", "manager"].includes(word);

  return (
    <div style={{ padding: 12, border: '1px solid #333', borderRadius: 8 }}>
      <h4 style={{ margin: 0, marginBottom: 10, color: '#FFD700' }}>{title}</h4>
      <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>
        {keywords.length > 0 ? keywords.map(({ word, count }, index) => (
          <li 
            key={index} 
            style={{ 
              display: 'flex', 
              justifyContent: 'space-between', 
              fontSize: 14, 
              padding: '4px 0',
              borderBottom: '1px dotted #444',
              color: isTrigger(word) ? '#FF4500' : 'white' 
            }}
          >
            <span style={{ fontWeight: isTrigger(word) ? 700 : 400 }}>{word}</span>
            <span style={{ color: '#aaa' }}>{count}</span>
          </li>
        )) : <li style={{ color: '#aaa' }}>No keywords found. (Check 'call_summary' column data)</li>}
      </ul>
    </div>
  );
}

// Analysis Box Component to display the Lodash results cleanly
function AnalysisBox({ title, data }) {
  return (
    <div style={{ padding: 12, border: '1px solid #333', borderRadius: 8 }}>
      <h4 style={{ margin: 0, marginBottom: 10, color: '#00BFFF' }}>{title}</h4>
      {data.length > 0 ? (
        <pre style={{ 
            fontSize: 12, 
            backgroundColor: '#333', 
            padding: 8, 
            borderRadius: 4, 
            overflowX: 'auto',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-all'
        }}>
          {JSON.stringify(data, null, 2)}
        </pre>
      ) : (
        <p style={{ fontSize: 14, color: '#aaa' }}>No data to display. (Check 'attempt_time' column)</p>
      )}
    </div>
  );
}
*/


import React, { useEffect, useMemo, useState } from "react";
import Papa from "papaparse";
import _ from "lodash";
import {
Â  BarChart,
Â  Bar,
Â  XAxis,
Â  YAxis,
Â  CartesianGrid,
Â  Tooltip,
Â  Legend,
Â  PieChart,
Â  Pie,
Â  Cell,
Â  LineChart,
Â  Line,
Â  ResponsiveContainer,
} from "recharts";

// ==========================================================
// HELPER FUNCTIONS
// ==========================================================

// Simple common English stop words for filtering
const STOP_WORDS = [
Â  "the",
Â  "a",
Â  "an",
Â  "and",
Â  "or",
Â  "but",
Â  "in",
Â  "on",
Â  "at",
Â  "to",
Â  "for",
Â  "of",
Â  "is",
Â  "was",
Â  "be",
Â  "it",
Â  "that",
Â  "this",
Â  "have",
Â  "with",
];

// Extracts keywords from text
function extractKeywords(text) {
Â  if (typeof text !== "string") return [];
Â  return text
Â  Â  .toLowerCase()
Â  Â  .replace(/[^\w\s]/g, " ")
Â  Â  .split(/\s+/)
Â  Â  .filter((word) => word.length > 3 && !STOP_WORDS.includes(word));
}

// Counts keyword frequency
const countKeywordFrequency = (keywordArrays) => {
Â  const wordCounts = {};
Â  keywordArrays.forEach((keywords) => {
Â  Â  keywords.forEach((word) => {
Â  Â  Â  wordCounts[word] = (wordCounts[word] || 0) + 1;
Â  Â  });
Â  });

Â  return Object.entries(wordCounts)
Â  Â  .sort(([, countA], [, countB]) => countB - countA)
Â  Â  .map(([word, count]) => ({ word, count }));
};

// Turn "HH:MM:SS" into total seconds
function parseHMS(hms) {
Â  if (!hms || typeof hms !== "string") return 0;
Â  const parts = hms.split(":").map(Number);
Â  if (parts.length === 3) {
Â  Â  const [hh, mm, ss] = parts;
Â  Â  if ([hh, mm, ss].some(Number.isNaN)) return 0;
Â  Â  return hh * 3600 + mm * 60 + ss;
Â  } else if (parts.length === 2) {
Â  Â  const [mm, ss] = parts;
Â  Â  if ([mm, ss].some(Number.isNaN)) return 0;
Â  Â  return mm * 60 + ss;
Â  } else if (parts.length === 1 && !Number.isNaN(parts[0])) {
Â  Â  return parts[0];
Â  }
Â  return 0;
}

// Turn seconds back into "HH:MM:SS"
function formatSecondsToHMS(totalSeconds) {
Â  const pad = (n) => String(n).padStart(2, "0");
Â  const s = Math.max(0, Math.floor(totalSeconds || 0));
Â  const hh = Math.floor(s / 3600);
Â  const mm = Math.floor((s % 3600) / 60);
Â  const ss = s % 60;
Â  return pad(hh) + ":" + pad(mm) + ":" + pad(ss);
}

// Convert "HH:MM:SS" to total minutes
function hmsToMinutes(hms) {
Â  if (typeof hms !== "string") return 0;
Â  const parts = hms.split(":");
Â  const h = parseInt(parts[0], 10) || 0;
Â  const m = parseInt(parts[1], 10) || 0;
Â  const s = parseInt(parts[2], 10) || 0;

Â  const totalSeconds = h * 3600 + m * 60 + s;
Â  return Math.round((totalSeconds / 60) * 100) / 100;
}

// Categorize duration
function categorizeDuration(minutes) {
Â  if (minutes < 2) return "Short"; // <2 min [cite: 52]
Â  if (minutes <= 5) return "Medium"; // 2-5 min [cite: 52]
Â  return "Long"; // >5 min [cite: 52]
}

// Normalize boolean values
function toBool(v) {
Â  if (v === true || v === false) return v;
Â  const s = String(v || "")
Â  Â  .trim()
Â  Â  .toLowerCase();
Â  return s === "y" || s === "yes" || s === "true" || s === "1";
}

// Extract hour from time string (assuming HH:MM:SS)
function extractHour(timeStr) {
Â  if (typeof timeStr !== "string") return 0;
Â  const timeParts = timeStr.split(":");
Â  return parseInt(timeParts[0], 10) || 0;
}

// StatCard component (Task 1: Overview/KPI Cards) [cite: 96]
function StatCard({ label, value }) {
Â  return (
Â  Â  <div
Â  Â  Â  style={{
Â  Â  Â  Â  border: "1px solid #eee",
Â  Â  Â  Â  borderRadius: 8,
Â  Â  Â  Â  padding: 12,
Â  Â  Â  Â  background: "white",
Â  Â  Â  Â  boxShadow: "0 1px 2px rgba(0,0,0,0.03)",
Â  Â  Â  Â  color: "#333",
Â  Â  Â  }}
Â  Â  >
Â  Â  Â  <div style={{ fontSize: 12, color: "#666", marginBottom: 6 }}>
Â  Â  Â  Â  {label}
Â  Â  Â  </div>
Â  Â  Â  <div style={{ fontSize: 18, fontWeight: 600 }}>{value}</div>
Â  Â  </div>
Â  );
}

// ==========================================================
// NEW COMPONENTS FOR DISPLAY (Task 2, 3, 4)
// ==========================================================

// Helper to structure chart data
const getChartData = (stats, rows) => {
Â  // 1. Outcome Bar Chart Data (PTP, RTP, Escalation) [cite: 103]
Â  const outcomeChartData = [
Â  Â  { name: "PTP Captured", count: stats.ptpCounts.true },
Â  Â  { name: "RTP Flagged", count: stats.rtpCounts.true },
Â  Â  { name: "Escalated", count: stats.escCounts.true },
Â  ];

Â  // 2. Duration Pie Chart Data [cite: 106]
Â  const durationChartData = Object.entries(stats.durationCategoryCounts)
Â  Â  .map(([name, value]) => ({
Â  Â  Â  name,
Â  Â  Â  value,
Â  Â  }))
Â  Â  .filter((d) => d.value > 0);

Â  // 3. Keyword Bar Chart Data (Top 10 Escalated Keywords) [cite: 105]
Â  const keywordChartData = stats.topKeywordsEscalated.map((item) => ({
Â  Â  word: item.word,
Â  Â  count: item.count,
Â  }));

Â  // 4. Calls Over Time (Daily Trend) [cite: 104]
Â  const callsByDate = _.chain(rows)
Â  Â  .groupBy("attempt_date") // Grouping by the date column (assuming it exists)
Â  Â  .map((calls, date) => ({
Â  Â  Â  date: date,
Â  Â  Â  totalCalls: calls.length,
Â  Â  }))
Â  Â  .sortBy("date")
Â  Â  .value();

Â  return { outcomeChartData, durationChartData, keywordChartData, callsByDate };
};

// --- CHART COMPONENTS (using Recharts) ---

// Pie Chart for Duration Distribution (Task 2)
const DurationPieChart = ({ data }) => {
Â  const COLORS = ["#00C49F", "#FFBB28", "#FF8042"];
Â  return (
Â  Â  <ResponsiveContainer width="100%" height="100%">
Â  Â  Â  <PieChart>
Â  Â  Â  Â  <Pie
Â  Â  Â  Â  Â  data={data}
Â  Â  Â  Â  Â  dataKey="value"
Â  Â  Â  Â  Â  nameKey="name"
Â  Â  Â  Â  Â  cx="50%"
Â  Â  Â  Â  Â  cy="50%"
Â  Â  Â  Â  Â  outerRadius={100}
Â  Â  Â  Â  Â  labelLine={false}
Â  Â  Â  Â  Â  label={({ name, percent }) =>
Â  Â  Â  Â  Â  Â  `${name}: ${(percent * 100).toFixed(0)}%`
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  >
Â  Â  Â  Â  Â  {data.map((entry, index) => (
Â  Â  Â  Â  Â  Â  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
Â  Â  Â  Â  Â  ))}
Â  Â  Â  Â  </Pie>
Â  Â  Â  Â  <Tooltip formatter={(value, name) => [`${value} calls`, name]} />
Â  Â  Â  Â  <Legend />
Â  Â  Â  </PieChart>
Â  Â  </ResponsiveContainer>
Â  );
};

// Bar Chart for Outcome Counts (Task 2)
const OutcomeBarChart = ({ data }) => {
Â  return (
Â  Â  <ResponsiveContainer width="100%" height="100%">
Â  Â  Â  <BarChart
Â  Â  Â  Â  data={data}
Â  Â  Â  Â  margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
Â  Â  Â  >
Â  Â  Â  Â  <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#ccc" />
Â  Â  Â  Â  <XAxis dataKey="name" stroke="#333" />
Â  Â  Â  Â  <YAxis allowDecimals={false} stroke="#333" />
Â  Â  Â  Â  <Tooltip />
Â  Â  Â  Â  <Legend />
Â  Â  Â  Â  <Bar dataKey="count" fill="#8884d8" name="Call Count" />
Â  Â  Â  </BarChart>
Â  Â  </ResponsiveContainer>
Â  );
};

// Bar Chart for Keywords (Task 2)
const KeywordBarChart = ({ data }) => {
Â  return (
Â  Â  <ResponsiveContainer width="100%" height="100%">
Â  Â  Â  <BarChart
Â  Â  Â  Â  layout="vertical"
Â  Â  Â  Â  data={data.slice(0, 10)}
Â  Â  Â  Â  margin={{ top: 20, right: 30, left: 100, bottom: 5 }}
Â  Â  Â  >
Â  Â  Â  Â  <CartesianGrid strokeDasharray="3 3" horizontal={false} stroke="#ccc" />
Â  Â  Â  Â  <XAxis type="number" stroke="#333" />
Â  Â  Â  Â  <YAxis dataKey="word" type="category" stroke="#333" width={90} />
Â  Â  Â  Â  <Tooltip />
Â  Â  Â  Â  <Bar dataKey="count" fill="#FFC658" name="Frequency" />
Â  Â  Â  </BarChart>
Â  Â  </ResponsiveContainer>
Â  );
};

// Line Chart for Calls Over Time (Task 2)
const CallsOverTimeChart = ({ data }) => {
Â  return (
Â  Â  <ResponsiveContainer width="100%" height="100%">
Â  Â  Â  <LineChart
Â  Â  Â  Â  data={data}
Â  Â  Â  Â  margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
Â  Â  Â  >
Â  Â  Â  Â  <CartesianGrid strokeDasharray="3 3" />
Â  Â  Â  Â  <XAxis dataKey="date" stroke="#333" />
Â  Â  Â  Â  <YAxis allowDecimals={false} stroke="#333" />
Â  Â  Â  Â  <Tooltip />
Â  Â  Â  Â  <Legend />
Â  Â  Â  Â  <Line
Â  Â  Â  Â  Â  type="monotone"
Â  Â  Â  Â  Â  dataKey="totalCalls"
Â  Â  Â  Â  Â  stroke="#82ca9d"
Â  Â  Â  Â  Â  name="Total Calls"
Â  Â  Â  Â  Â  strokeWidth={2}
Â  Â  Â  Â  />
Â  Â  Â  </LineChart>
Â  Â  </ResponsiveContainer>
Â  );
};

// Analysis Box Component (for raw data display)
function AnalysisBox({ title, data }) {
Â  return (
Â  Â  <div style={{ padding: 12, border: "1px solid #333", borderRadius: 8 }}>
Â  Â  Â  <h4 style={{ margin: 0, marginBottom: 10, color: "#00BFFF" }}>{title}</h4>
Â  Â  Â  {data.length > 0 ? (
Â  Â  Â  Â  <pre
Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  fontSize: 12,
Â  Â  Â  Â  Â  Â  backgroundColor: "#333",
Â  Â  Â  Â  Â  Â  padding: 8,
Â  Â  Â  Â  Â  Â  borderRadius: 4,
Â  Â  Â  Â  Â  Â  overflowX: "auto",
Â  Â  Â  Â  Â  Â  whiteSpace: "pre-wrap",
Â  Â  Â  Â  Â  Â  wordBreak: "break-all",
Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  >
Â  Â  Â  Â  Â  {JSON.stringify(data, null, 2)}
Â  Â  Â  Â  </pre>
Â  Â  Â  ) : (
Â  Â  Â  Â  <p style={{ fontSize: 14, color: "#aaa" }}>
Â  Â  Â  Â  Â  No data to display. (Check 'attempt_time' column)
Â  Â  Â  Â  </p>
Â  Â  Â  )}
Â  Â  </div>
Â  );
}

// Keyword List Component (for text analysis display)
function KeywordList({ title, keywords }) {
Â  const isTrigger = (word) =>
Â  Â  ["fraud", "paid", "issue", "refund", "complaint", "manager"].includes(word);

Â  return (
Â  Â  <div style={{ padding: 12, border: "1px solid #333", borderRadius: 8 }}>
Â  Â  Â  <h4 style={{ margin: 0, marginBottom: 10, color: "#FFD700" }}>{title}</h4>
Â  Â  Â  <ul style={{ listStyle: "none", padding: 0, margin: 0 }}>
Â  Â  Â  Â  {keywords.length > 0 ? (
Â  Â  Â  Â  Â  keywords.map(({ word, count }, index) => (
Â  Â  Â  Â  Â  Â  <li
Â  Â  Â  Â  Â  Â  Â  key={index}
Â  Â  Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  Â  Â  display: "flex",
Â  Â  Â  Â  Â  Â  Â  Â  justifyContent: "space-between",
Â  Â  Â  Â  Â  Â  Â  Â  fontSize: 14,
Â  Â  Â  Â  Â  Â  Â  Â  padding: "4px 0",
Â  Â  Â  Â  Â  Â  Â  Â  borderBottom: "1px dotted #444",
Â  Â  Â  Â  Â  Â  Â  Â  color: isTrigger(word) ? "#FF4500" : "white",
Â  Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  <span style={{ fontWeight: isTrigger(word) ? 700 : 400 }}>
Â  Â  Â  Â  Â  Â  Â  Â  {word}
Â  Â  Â  Â  Â  Â  Â  </span>
Â  Â  Â  Â  Â  Â  Â  <span style={{ color: "#aaa" }}>{count}</span>
Â  Â  Â  Â  Â  Â  </li>
Â  Â  Â  Â  Â  ))
Â  Â  Â  Â  ) : (
Â  Â  Â  Â  Â  <li style={{ color: "#aaa" }}>
Â  Â  Â  Â  Â  Â  No keywords found. (Check 'call_summary' column data)
Â  Â  Â  Â  Â  </li>
Â  Â  Â  Â  )}
Â  Â  Â  </ul>
Â  Â  </div>
Â  );
}

// Insight Card Component (Task 4: Insights Section) [cite: 110]
function InsightCard({ title, text }) {
Â  return (
Â  Â  <div
Â  Â  Â  style={{
Â  Â  Â  Â  padding: 12,
Â  Â  Â  Â  border: "1px solid #444",
Â  Â  Â  Â  borderRadius: 8,
Â  Â  Â  Â  background: "#333",
Â  Â  Â  }}
Â  Â  >
Â  Â  Â  <h5 style={{ margin: 0, color: "#00BFFF" }}>{title}</h5>
Â  Â  Â  <p style={{ margin: 0, fontSize: 13, color: "#aaa" }}>{text}</p>
Â  Â  </div>
Â  );
}

// ==========================================================
// MAIN COMPONENT
// ==========================================================

export default function CallsSummary() {
Â  const [rows, setRows] = useState([]);
Â  const [loading, setLoading] = useState(true);
Â  const [errorMsg, setErrorMsg] = useState("");
Â  // States for simple filters (Task 3)
Â  const [selectedOutcome, setSelectedOutcome] = useState("All");
Â  const [startDate, setStartDate] = useState(null);
Â  const [endDate, setEndDate] = useState(null);

Â  useEffect(() => {
Â  Â  setLoading(true);
Â  Â  setErrorMsg("");
Â  Â  Papa.parse("./riddhiproject.csv", {
Â  Â  Â  header: true,
Â  Â  Â  download: true,
Â  Â  Â  skipEmptyLines: true,
Â  Â  Â  dynamicTyping: false,
Â  Â  Â  complete: (results) => {
Â  Â  Â  Â  setRows(results.data || []);
Â  Â  Â  Â  setLoading(false);
Â  Â  Â  },
Â  Â  Â  error: (err) => {
Â  Â  Â  Â  setErrorMsg(err?.message || "Failed to load CSV");
Â  Â  Â  Â  setLoading(false);
Â  Â  Â  },
Â  Â  });
Â  }, []);

Â  const stats = useMemo(() => {
Â  Â  if (!rows.length) {
Â  Â  Â  return {
Â  Â  Â  Â  total: 0,
Â  Â  Â  Â  avgHMS: "00:00:00",
Â  Â  Â  Â  ptpCounts: { true: 0, false: 0 },
Â  Â  Â  Â  rtpCounts: { true: 0, false: 0 },
Â  Â  Â  Â  escCounts: { true: 0, false: 0 },
Â  Â  Â  Â  successRate: 0,
Â  Â  Â  Â  escalationRate: 0,
Â  Â  Â  Â  durationCategoryCounts: { Short: 0, Medium: 0, Long: 0 },
Â  Â  Â  Â  topKeywordsEscalated: [],
Â  Â  Â  Â  topKeywordsNonEscalated: [],
Â  Â  Â  Â  successRateByHour: [],
Â  Â  Â  Â  escalationRateByDuration: [],
Â  Â  Â  Â  avgDurationByPtpStatus: [],
Â  Â  Â  Â  outcomeChartData: [],
Â  Â  Â  Â  durationChartData: [],
Â  Â  Â  Â  keywordChartData: [],
Â  Â  Â  Â  callsByDate: [],
Â  Â  Â  };
Â  Â  }

Â  Â  // ==========================================================
Â  Â  // FEATURE ENGINEERING & DATA TRANSFORMATION
Â  Â  // ==========================================================
Â  Â  const processedRows = rows.map((row) => {
Â  Â  Â  const durationMinutes = hmsToMinutes(row.call_duration);
Â  Â  Â  const durationCategory = categorizeDuration(durationMinutes);
Â  Â  Â  const attemptHour = extractHour(row.attempt_time);
Â  Â  Â  const is_ptp = toBool(row.ptp_captured || row.ptp); // Assuming ptp_captured or ptp column [cite: 19]
Â  Â  Â  const is_escalated = toBool(row.escalation); // [cite: 21]

Â  Â  Â  return {
Â  Â  Â  Â  ...row,
Â  Â  Â  Â  call_duration_minutes: durationMinutes,
Â  Â  Â  Â  duration_category: durationCategory,
Â  Â  Â  Â  attempt_hour: attemptHour,
Â  Â  Â  Â  is_ptp: is_ptp,
Â  Â  Â  Â  is_escalated: is_escalated,
Â  Â  Â  Â  keywords: extractKeywords(row.call_summary),
Â  Â  Â  };
Â  Â  });

Â  Â  // STATS CALCULATION using processedRows
Â  Â  const total = processedRows.length;
Â  Â  const secs = processedRows.map((r) => parseHMS(r.call_duration));
Â  Â  const sumSecs = secs.reduce((a, b) => a + (Number.isFinite(b) ? b : 0), 0);
Â  Â  const avgSecs = total > 0 ? sumSecs / total : 0;
Â  Â  const avgHMS = formatSecondsToHMS(avgSecs);

Â  Â  const ptpBools = processedRows.map((r) => r.is_ptp);
Â  Â  const rtpBools = processedRows.map((r) => toBool(r.rtp_flagged || r.rtp)); // Assuming rtp_flagged or rtp column [cite: 20]
Â  Â  const escBools = processedRows.map((r) => r.is_escalated);

Â  Â  const countTrueFalse = (arr) => ({
Â  Â  Â  true: arr.filter(Boolean).length,
Â  Â  Â  false: arr.filter((x) => !x).length,
Â  Â  });

Â  Â  const countCategories = (arr) =>
Â  Â  Â  arr.reduce(
Â  Â  Â  Â  (acc, val) => {
Â  Â  Â  Â  Â  acc[val] = (acc[val] || 0) + 1;
Â  Â  Â  Â  Â  return acc;
Â  Â  Â  Â  },
Â  Â  Â  Â  { Short: 0, Medium: 0, Long: 0 }
Â  Â  Â  );

Â  Â  const ptpCounts = countTrueFalse(ptpBools);
Â  Â  const rtpCounts = countTrueFalse(rtpBools);
Â  Â  const escCounts = countTrueFalse(escBools);

Â  Â  const durationCategoryCounts = countCategories(
Â  Â  Â  processedRows.map((r) => r.duration_category)
Â  Â  );
Â  Â  const successRate = total ? (ptpCounts.true / total) * 100 : 0; // [cite: 31]
Â  Â  const escalationRate = total ? (escCounts.true / total) * 100 : 0; // [cite: 32]

Â  Â  // TEXT ANALYSIS
Â  Â  const escalatedCalls = processedRows.filter((r) => r.is_escalated);
Â  Â  const nonEscalatedCalls = processedRows.filter((r) => !r.is_escalated);
Â  Â  const topKeywordsEscalated = countKeywordFrequency(
Â  Â  Â  escalatedCalls.map((r) => r.keywords)
Â  Â  ).slice(0, 10);
Â  Â  const topKeywordsNonEscalated = countKeywordFrequency(
Â  Â  Â  nonEscalatedCalls.map((r) => r.keywords)
Â  Â  ).slice(0, 10);

Â  Â  // BASIC STATISTICAL ANALYSIS (Lodash)
Â  Â  const successRateByHour = _.chain(processedRows)
Â  Â  Â  .groupBy("attempt_hour")
Â  Â  Â  .map((calls, hour) => ({
Â  Â  Â  Â  hour: parseInt(hour, 10),
Â  Â  Â  Â  successRate:
Â  Â  Â  Â  Â  (_.filter(calls, { is_ptp: true }).length / calls.length) * 100,
Â  Â  Â  Â  totalCalls: calls.length,
Â  Â  Â  }))
Â  Â  Â  .sortBy("hour")
Â  Â  Â  .value();

Â  Â  const escalationRateByDuration = _.chain(processedRows)
Â  Â  Â  .groupBy("duration_category")
Â  Â  Â  .map((calls, category) => ({
Â  Â  Â  Â  category: category,
Â  Â  Â  Â  escalationRate:
Â  Â  Â  Â  Â  (_.filter(calls, { is_escalated: true }).length / calls.length) * 100,
Â  Â  Â  Â  totalCalls: calls.length,
Â  Â  Â  }))
Â  Â  Â  .value();

Â  Â  const avgDurationByPtpStatus = _.chain(processedRows)
Â  Â  Â  .groupBy("is_ptp")
Â  Â  Â  .map((calls, isPtp) => ({
Â  Â  Â  Â  ptpStatus: isPtp === "true" ? "PTP Captured" : "No PTP",
Â  Â  Â  Â  avgDurationMinutes:
Â  Â  Â  Â  Â  _.sumBy(calls, "call_duration_minutes") / calls.length,
Â  Â  Â  Â  totalCalls: calls.length,
Â  Â  Â  }))
Â  Â  Â  .value();

Â  Â  // CHART DATA STRUCTURES
Â  Â  const {
Â  Â  Â  outcomeChartData,
Â  Â  Â  durationChartData,
Â  Â  Â  keywordChartData,
Â  Â  Â  callsByDate,
Â  Â  } = getChartData(
Â  Â  Â  {
Â  Â  Â  Â  ptpCounts,
Â  Â  Â  Â  rtpCounts,
Â  Â  Â  Â  escCounts,
Â  Â  Â  Â  durationCategoryCounts,
Â  Â  Â  Â  topKeywordsEscalated,
Â  Â  Â  },
Â  Â  Â  rows
Â  Â  );

Â  Â  return {
Â  Â  Â  total,
Â  Â  Â  avgHMS,
Â  Â  Â  ptpCounts,
Â  Â  Â  rtpCounts,
Â  Â  Â  escCounts,
Â  Â  Â  successRate,
Â  Â  Â  escalationRate,
Â  Â  Â  durationCategoryCounts,
Â  Â  Â  topKeywordsEscalated,
Â  Â  Â  topKeywordsNonEscalated,
Â  Â  Â  successRateByHour,
Â  Â  Â  escalationRateByDuration,
Â  Â  Â  avgDurationByPtpStatus,
Â  Â  Â  outcomeChartData,
Â  Â  Â  durationChartData,
Â  Â  Â  keywordChartData,
Â  Â  Â  callsByDate,
Â  Â  };
Â  }, [rows]);

Â  if (loading) {
Â  Â  return (
Â  Â  Â  <div style={{ padding: 16, background: "#212121", color: "white" }}>
Â  Â  Â  Â  Loading CSVâ€¦
Â  Â  Â  </div>
Â  Â  );
Â  }
Â  if (errorMsg) {
Â  Â  return (
Â  Â  Â  <div style={{ padding: 16, color: "crimson", background: "#212121" }}>
Â  Â  Â  Â  Error: {errorMsg}
Â  Â  Â  </div>
Â  Â  );
Â  }

Â  // ==========================================================
Â  // JSX RENDERING (OUTPUT)
Â  // ==========================================================
Â /* return (
Â  Â  <div
Â  Â  Â  style={{
Â  Â  Â  Â  fontFamily: "system-ui, -apple-system, Segoe UI, Roboto, sans-serif",
Â  Â  Â  Â  background: "#212121",
Â  Â  Â  Â  color: "white",
        minHeight: '100vh',
        width: '100vw',
        boxSizing: 'border-box',
        padding: '16px', 
Â  Â  Â  }}
Â  Â  >
  Â  Â  <h2 style={{ marginTop: 0, marginBottom: 20}}>DEBT COLLECTION CALL DATA</h2>
Â  Â  Â  <h3 style={{ marginTop: 24, marginBottom: 16 }}>Basic Filters</h3>
Â  Â  Â  <div
Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  display: "flex",
Â  Â  Â  Â  Â  gap: 20,
Â  Â  Â  Â  Â  padding: 10,
Â  Â  Â  Â  Â  border: "1px solid #333",
Â  Â  Â  Â  Â  borderRadius: 8,
          flexWrap: "wrap", 
          marginBottom: 20,
Â  Â  Â  Â  }}
Â  Â  Â  >
Â  Â  Â  Â  <select
Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  padding: 8,
Â  Â  Â  Â  Â  Â  background: "#333",
Â  Â  Â  Â  Â  Â  color: "white",
Â  Â  Â  Â  Â  Â  border: "none",
Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  value={selectedOutcome}
Â  Â  Â  Â  Â  onChange={(e) => setSelectedOutcome(e.target.value)}
Â  Â  Â  Â  >
Â  Â  Â  Â  Â  <option value="All">All Outcomes</option>
Â  Â  Â  Â  Â  <option value="PTP">PTP Captured (TRUE)</option>
Â  Â  Â  Â  Â  <option value="Escalation">Escalation (TRUE)</option>
Â  Â  Â  Â  Â  <option value="RTP">RTP Flagged (TRUE)</option>
Â  Â  Â  Â  </select>
Â  Â  Â  Â  <div style={{ color: "#aaa", display: "flex", alignItems: "center" }}>
Â  Â  Â  Â  Â  Date Range: [Date Picker UI Placeholder]
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  {/* Task 1: Basic Stat Cards */ /*}
Â  Â  Â  <div
Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  display: "grid",
Â  Â  Â  Â  Â  gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))",
Â  Â  Â  Â  Â  gap: 12,
Â  Â  Â  Â  Â  marginTop: 20,
          marginBottom: 40,
Â  Â  Â  Â  }}
Â  Â  Â  >
Â  Â  Â  Â  <StatCard label="Total Calls" value={stats.total} /> {/* [cite: 97] */ /*}
Â  Â  Â  Â  <StatCard label="Average Call Duration" value={stats.avgHMS} />{" "}
Â  Â  Â  Â  {/* [cite: 100] */ /*}
Â  Â  Â  Â  <StatCard
Â  Â  Â  Â  Â  label="PTP: True / False"
Â  Â  Â  Â  Â  value={
Â  Â  Â  Â  Â  Â  String(stats.ptpCounts.true) + " / " + String(stats.ptpCounts.false)
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  />
Â  Â  Â  Â  <StatCard
Â  Â  Â  Â  Â  label="RTP: True / False"
Â  Â  Â  Â  Â  value={
Â  Â  Â  Â  Â  Â  String(stats.rtpCounts.true) + " / " + String(stats.rtpCounts.false)
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  />
Â  Â  Â  Â  <StatCard
Â  Â  Â  Â  Â  label="Escalations: True / False"
Â  Â  Â  Â  Â  value={
Â  Â  Â  Â  Â  Â  String(stats.escCounts.true) + " / " + String(stats.escCounts.false)
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  />
Â  Â  Â  Â  <StatCard
Â  Â  Â  Â  Â  label="Success Rate (PTP %)"
Â  Â  Â  Â  Â  value={stats.successRate.toFixed(1) + "%"}
Â  Â  Â  Â  />
Â  Â  Â  Â  <StatCard
Â  Â  Â  Â  Â  label="Escalation Rate (%)"
Â  Â  Â  Â  Â  value={stats.escalationRate.toFixed(1) + "%"}
Â  Â  Â  Â  />
Â  Â  Â  Â  {/* Duration Stats */ /*}
Â  Â  Â  Â  <StatCard
Â  Â  Â  Â  Â  label="Short Calls (< 2 min)"
Â  Â  Â  Â  Â  value={stats.durationCategoryCounts.Short}
Â  Â  Â  Â  />
Â  Â  Â  Â  <StatCard
Â  Â  Â  Â  Â  label="Medium Calls (2-5 min)"
Â  Â  Â  Â  Â  value={stats.durationCategoryCounts.Medium}
Â  Â  Â  Â  />
Â  Â  Â  Â  <StatCard
Â  Â  Â  Â  Â  label="Long Calls (> 5 min)"
Â  Â  Â  Â  Â  value={stats.durationCategoryCounts.Long}
Â  Â  Â  Â  />
Â  Â  Â  </div>
Â  Â  Â  {/* Task 2: Core Visualizations */ /*}
Â  Â  Â  <h3 style={{ marginTop: 40, marginBottom: 20 }}>Core Visualizations</h3>
Â  Â  Â  <div
Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  display: "grid",
Â  Â  Â  Â  Â  gridTemplateColumns: "repeat(auto-fit, minmax(400px, 1fr))",
Â  Â  Â  Â  Â  gap: 24,
Â  Â  Â  Â  Â  background: "#333",
Â  Â  Â  Â  Â  padding: 20,
Â  Â  Â  Â  Â  borderRadius: 8,
          marginBottom: 40,
Â  Â  Â  Â  }}
Â  Â  Â  >
Â  Â  Â  Â  {/* Bar Chart: PTP, RTP, Escalations Count [cite: 103] */ /*}
Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  height: 350,
Â  Â  Â  Â  Â  Â  background: "white",
Â  Â  Â  Â  Â  Â  padding: 40,
Â  Â  Â  Â  Â  Â  borderRadius: 4,
            minWidth: 0
Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  >
Â  Â  Â  Â  Â  <h4 style={{ color: "#333", textAlign: "center" }}>
Â  Â  Â  Â  Â  Â  PTP, RTP, & Escalation Counts
Â  Â  Â  Â  Â  </h4>
Â  Â  Â  Â  Â  <OutcomeBarChart data={stats.outcomeChartData} />
Â  Â  Â  Â  </div>

Â  Â  Â  Â  {/* Pie Chart: Call Duration Distribution [cite: 106] */ /*} 
Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  height: 350,
Â  Â  Â  Â  Â  Â  background: "white",
Â  Â  Â  Â  Â  Â  padding: 40,
Â  Â  Â  Â  Â  Â  borderRadius: 4,
minWidth: 0
Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  >
Â  Â  Â  Â  Â  <h4 style={{ color: "#333", textAlign: "center" }}>
Â  Â  Â  Â  Â  Â  Call Duration Distribution
Â  Â  Â  Â  Â  </h4>
Â  Â  Â  Â  Â  <DurationPieChart data={stats.durationChartData} />
Â  Â  Â  Â  </div>

Â  Â  Â  Â  {/* Bar Chart: Top 10 Keywords [cite: 105] */ /*}
Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  height: 350,
Â  Â  Â  Â  Â  Â  background: "white",
Â  Â  Â  Â  Â  Â  padding: 60,
Â  Â  Â  Â  Â  Â  borderRadius: 4,
minWidth: 0
Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  >
Â  Â  Â  Â  Â  <h4 style={{ color: "#333", textAlign: "center" }}>
Â  Â  Â  Â  Â  Â  Top 10 Keywords (Escalated)
Â  Â  Â  Â  Â  </h4>
Â  Â  Â  Â  Â  <KeywordBarChart data={stats.keywordChartData} />
Â  Â  Â  Â  </div>

Â  Â  Â  Â  {/* Line Chart: Calls Over Time (Daily Trend) [cite: 104] */ /*}
Â  Â  Â  Â  <div
Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  height: 350,
Â  Â  Â  Â  Â  Â  background: "white",
Â  Â  Â  Â  Â  Â  padding: 40,
Â  Â  Â  Â  Â  Â  borderRadius: 4,
minWidth: 0
Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  >
Â  Â  Â  Â  Â  <h4 style={{ color: "#333", textAlign: "center" }}>
Â  Â  Â  Â  Â  Â  Calls Over Time (Daily Trend)
Â  Â  Â  Â  Â  </h4>
Â  Â  Â  Â  Â  <CallsOverTimeChart data={stats.callsByDate} />
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  {/* Task 4: Insights Section */ /*}
Â  Â  Â  <h3 style={{ marginTop: 40, marginBottom: 20 }}>Key Insights</h3> {/* [cite: 110] */ /*}
Â  Â  Â  <div
Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  display: "grid",
Â  Â  Â  Â  Â  gridTemplateColumns: "repeat(auto-fit, minmax(300px, 1fr))",
Â  Â  Â  Â  Â  gap: 12,
marginBottom: 40,
Â  Â  Â  Â  }}
Â  Â  Â  >
Â  Â  Â  Â  <InsightCard
Â  Â  Â  Â  Â  title="Escalation Risk"
Â  Â  Â  Â  Â  text={`The overall escalation rate is high (${stats.escalationRate.toFixed(
Â  Â  Â  Â  Â  Â  1
Â  Â  Â  Â  Â  )}%). Long calls (> 5 min) have an escalation rate of ${
Â  Â  Â  Â  Â  Â  stats.escalationRateByDuration
Â  Â  Â  Â  Â  Â  Â  .find((d) => d.category === "Long")
Â  Â  Â  Â  Â  Â  Â  ?.escalationRate.toFixed(1) || 0
Â  Â  Â  Â  Â  }%, suggesting complex issues require supervisor intervention.`}
Â  Â  Â  Â  />
Â  Â  Â  Â  <InsightCard
Â  Â  Â  Â  Â  title="Average Success Duration"
Â  Â  Â  Â  Â  text={`PTP-captured calls take an average of ${
Â  Â  Â  Â  Â  Â  stats.avgDurationByPtpStatus
Â  Â  Â  Â  Â  Â  Â  .find((d) => d.ptpStatus === "PTP Captured")
Â  Â  Â  Â  Â  Â  Â  ?.avgDurationMinutes.toFixed(2) || 0
Â  Â  Â  Â  Â  } minutes, indicating that successful resolution requires sustained effort.`}
Â  Â  Â  Â  />
Â  Â  Â  Â  <InsightCard
Â  Â  Â  Â  Â  title="Keyword Focus"
Â  Â  Â  Â  Â  text={`The top keywords in escalated calls ('payment', 'card', 'credit') confirm that friction is concentrated around financial transaction details and account status.`}
Â  Â  Â  Â  />
Â  Â  Â  Â  <InsightCard
Â  Â  Â  Â  Â  title="PTP Capture Rate"
Â  Â  Â  Â  Â  text={`Only ${stats.successRate.toFixed(
Â  Â  Â  Â  Â  Â  1
Â  Â  Â  Â  Â  )}% of total calls result in a PTP. Compare this to the success rate by hour to find the optimal calling window.`}
Â  Â  Â  Â  />
Â  Â  Â  Â  <InsightCard
Â  Â  Â  Â  Â  title="Short Call Volume"
Â  Â  Â  Â  Â  text={`The highest volume is in the Short category, at ${stats.durationCategoryCounts.Short} calls. This may indicate abandoned attempts or very quick information transfers.`}
Â  Â  Â  Â  />
Â  Â  Â  </div>

Â  Â  Â  {/* Raw Statistical Analysis (for inspection) */ /*}
Â  Â  Â  <h3 style={{ marginTop: 32, marginBottom: 20 }}>Basic Statistical Analysis (Raw Data)</h3>
Â  Â  Â  <div
Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  display: "grid",
Â  Â  Â  Â  Â  gridTemplateColumns: "repeat(auto-fit, minmax(300px, 1fr))",
Â  Â  Â  Â  Â  gap: 16,
marginBottom: 40,
Â  Â  Â  Â  }}
Â  Â  Â  >
Â  Â  Â  Â  <AnalysisBox
Â  Â  Â  Â  Â  title="Success Rate by Hour of Day"
Â  Â  Â  Â  Â  data={stats.successRateByHour}
Â  Â  Â  Â  />
Â  Â  Â  Â  <AnalysisBox
Â  Â  Â  Â  Â  title="Escalation Rate by Duration Category"
Â  Â  Â  Â  Â  data={stats.escalationRateByDuration}
Â  Â  Â  Â  />
Â  Â  Â  Â  <AnalysisBox
Â  Â  Â  Â  Â  title="Average Duration by PTP Status"
Â  Â  Â  Â  Â  data={stats.avgDurationByPtpStatus}
Â  Â  Â  Â  />
Â  Â  Â  </div>

Â  Â  Â  {/* Text Analysis Output */ /*}
Â  Â  Â  <h3 style={{ marginTop: 32, marginBottom: 20 }}>Call Summary Keyword Analysis</h3>
Â  Â  Â  <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16, marginBottom: 40 }}>
Â  Â  Â  Â  <KeywordList
Â  Â  Â  Â  Â  title="Top 10 Keywords in ESCALATED Calls"
Â  Â  Â  Â  Â  keywords={stats.topKeywordsEscalated}
Â  Â  Â  Â  Â  isEscalated={true}
Â  Â  Â  Â  />
Â  Â  Â  Â  <KeywordList
Â  Â  Â  Â  Â  title="Top 10 Keywords in NON-ESCALATED Calls"
Â  Â  Â  Â  Â  keywords={stats.topKeywordsNonEscalated}
Â  Â  Â  Â  Â  isEscalated={false}
Â  Â  Â  Â  />
Â  Â  Â  </div>
Â  Â  Â  {/* Sample Rows */ /*}
Â  Â  Â  <h3 style={{ marginTop: 24, marginBottom: 8 }}>Sample Rows</h3>
Â  Â  Â  <div style={{ fontSize: 12, color: "#999", marginBottom: 8 }}>
Â  Â  Â  Â  Showing the first 5 rows so you can confirm columns look right.
Â  Â  Â  </div>
Â  Â  Â  <table
Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  width: "100%",
Â  Â  Â  Â  Â  borderCollapse: "collapse",
Â  Â  Â  Â  Â  textAlign: "left",
Â  Â  Â  Â  Â  color: "white",
Â  Â  Â  Â  }}
Â  Â  Â  >
Â  Â  Â  Â  <thead>
Â  Â  Â  Â  Â  <tr style={{ backgroundColor: "#424242" }}>
Â  Â  Â  Â  Â  Â  <th style={{ padding: "8px" }}>customer_id</th>
Â  Â  Â  Â  Â  Â  <th style={{ padding: "8px" }}>ptp</th>
Â  Â  Â  Â  Â  Â  <th style={{ padding: "8px" }}>rtp</th>
Â  Â  Â  Â  Â  Â  <th style={{ padding: "8px" }}>call_duration</th>
Â  Â  Â  Â  Â  Â  <th style={{ padding: "8px" }}>escalation</th>
Â  Â  Â  Â  Â  Â  <th style={{ padding: "8px" }}>Minutes</th>
Â  Â  Â  Â  Â  Â  <th style={{ padding: "8px" }}>Category</th>
Â  Â  Â  Â  Â  </tr>
Â  Â  Â  Â  </thead>
Â  Â  Â  Â  <tbody>
Â  Â  Â  Â  Â  {rows.slice(0, 5).map((r, idx) => {
Â  Â  Â  Â  Â  Â  const durationMinutes = hmsToMinutes(r.call_duration);
Â  Â  Â  Â  Â  Â  const durationCategory = categorizeDuration(durationMinutes);

Â  Â  Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  Â  Â  <tr
Â  Â  Â  Â  Â  Â  Â  Â  key={idx}
Â  Â  Â  Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  Â  Â  Â  borderBottom: "1px solid #666",
Â  Â  Â  Â  Â  Â  Â  Â  Â  backgroundColor: idx % 2 === 0 ? "#303030" : "#212121",
Â  Â  Â  Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Â  <td style={{ padding: "8px" }}>{r.customer_id}</td>
Â  Â  Â  Â  Â  Â  Â  Â  <td style={{ padding: "8px" }}>{String(r.ptp)}</td>
Â  Â  Â  Â  Â  Â  Â  Â  <td style={{ padding: "8px" }}>{String(r.rtp)}</td>
Â  Â  Â  Â  Â  Â  Â  Â  <td style={{ padding: "8px" }}>{r.call_duration}</td>
Â  Â  Â  Â  Â  Â  Â  Â  <td style={{ padding: "8px" }}>{String(r.escalation)}</td>
Â  Â  Â  Â  Â  Â  Â  Â  <td style={{ padding: "8px" }}>{durationMinutes.toFixed(2)}</td>
Â  Â  Â  Â  Â  Â  Â  Â  <td style={{ padding: "8px" }}>{durationCategory}</td>
Â  Â  Â  Â  Â  Â  Â  </tr>
Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  })}
Â  Â  Â  Â  </tbody>
Â  Â  Â  </table>
</div>
Â  ); */

return (
  <div
    style={{
      width: "100vw",
      minHeight: "100vh",
      background: "#212121",
      color: "white",
      fontFamily: "system-ui, -apple-system, Segoe UI, Roboto, sans-serif",
      boxSizing: "border-box"
    }}
  >
    {/* Center all content with maxWidth and padding for whitespace */}
    <div style={{
      maxWidth: 1200,
      margin: "0 auto",
      padding: "32px 24px 24px 24px",
      width: "100%"
    }}>
      <h2 style={{ fontWeight: 800, marginTop: 0, marginBottom: 10, fontSize: 30, letterSpacing: 1 }}>DEBT COLLECTION CALL DATA</h2>
      <h3 style={{ fontWeight: 600, fontSize: 22, marginTop: 16, marginBottom: 16 }}>Basic Filters</h3>

      {/* Filters */}
      <div
        style={{
          display: "flex",
          gap: 20,
          padding: 14,
          border: "1px solid #333",
          borderRadius: 10,
          background: "#232323",
          flexWrap: "wrap",
          marginBottom: 20,
        }}
      >
        <select
          style={{
            padding: 10,
            background: "#333",
            color: "white",
            border: "none",
            borderRadius: 6,
            fontSize: 16,
          }}
          value={selectedOutcome}
          onChange={(e) => setSelectedOutcome(e.target.value)}
        >
          <option value="All">All Outcomes</option>
          <option value="PTP">PTP Captured (TRUE)</option>
          <option value="Escalation">Escalation (TRUE)</option>
          <option value="RTP">RTP Flagged (TRUE)</option>
        </select>
        <div style={{ color: "#aaa", display: "flex", alignItems: "center", fontSize: 16 }}>
          Date Range: [Date Picker UI Placeholder]
        </div>
      </div>

      {/* Stat Cards */}
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))",
          gap: 20,
          marginTop: 24,
          marginBottom: 32,
        }}
      >
        {/* Add card styling inside StatCard as shown below */}
        <StatCard label="Total Calls" value={stats.total} />
        <StatCard label="Average Call Duration" value={stats.avgHMS} />
        <StatCard label="PTP: True / False" value={`${stats.ptpCounts.true} / ${stats.ptpCounts.false}`} />
        <StatCard label="RTP: True / False" value={`${stats.rtpCounts.true} / ${stats.rtpCounts.false}`} />
        <StatCard label="Escalations: True / False" value={`${stats.escCounts.true} / ${stats.escCounts.false}`} />
        <StatCard label="Success Rate (PTP %)" value={stats.successRate.toFixed(1) + "%"} />
        <StatCard label="Escalation Rate (%)" value={stats.escalationRate.toFixed(1) + "%"} />
        <StatCard label="Short Calls (< 2 min)" value={stats.durationCategoryCounts.Short} />
        <StatCard label="Medium Calls (2-5 min)" value={stats.durationCategoryCounts.Medium} />
        <StatCard label="Long Calls (> 5 min)" value={stats.durationCategoryCounts.Long} />
      </div>

      {/* Core Visualizations */}
      <h3 style={{ fontWeight: 600, fontSize: 20, marginTop: 32, marginBottom: 16 }}>Core Visualizations</h3>
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(400px, 1fr))",
          gap: 28,
          marginBottom: 40,
        }}
      >
        {/* Card container for each chart */}
        <div
          style={{
            background: "#232323",
            borderRadius: 10,
            boxShadow: "0 2px 8px #00000012",
            padding: 32,
            minHeight: 380,
            minWidth: 0,
            height: "100%",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <h4 style={{ color: "#eee", textAlign: "center", marginBottom: 12 }}>
            PTP, RTP, & Escalation Counts
          </h4>
          <OutcomeBarChart data={stats.outcomeChartData} />
        </div>
        <div style={{
          background: "#232323",
          borderRadius: 10,
          boxShadow: "0 2px 8px #00000012",
          padding: 32,
          minHeight: 380,
          minWidth: 0,
          height: "100%",
          display: "flex",
          flexDirection: "column",
        }}>
          <h4 style={{ color: "#eee", textAlign: "center", marginBottom: 12 }}>
            Call Duration Distribution
          </h4>
          <DurationPieChart data={stats.durationChartData} />
        </div>
        <div style={{
          background: "#232323",
          borderRadius: 10,
          boxShadow: "0 2px 8px #00000012",
          padding: 32,
          minHeight: 380,
          minWidth: 0,
          height: "100%",
          display: "flex",
          flexDirection: "column"
        }}>
          <h4 style={{ color: "#eee", textAlign: "center", marginBottom: 12 }}>
            Top 10 Keywords (Escalated)
          </h4>
          <KeywordBarChart data={stats.keywordChartData} />
        </div>
        <div style={{
          background: "#232323",
          borderRadius: 10,
          boxShadow: "0 2px 8px #00000012",
          padding: 32,
          minHeight: 380,
          minWidth: 0,
          height: "100%",
          display: "flex",
          flexDirection: "column"
        }}>
          <h4 style={{ color: "#eee", textAlign: "center", marginBottom: 12 }}>
            Calls Over Time (Daily Trend)
          </h4>
          <CallsOverTimeChart data={stats.callsByDate} />
        </div>
      </div>

      {/* Insights Section */}
      <h3 style={{ fontWeight: 600, fontSize: 20, marginTop: 32, marginBottom: 16 }}>Key Insights</h3>
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(250px, 1fr))",
          gap: 20,
          marginBottom: 36,
        }}
      >
        <InsightCard title="Escalation Risk" text={`The overall escalation rate is high (${stats.escalationRate.toFixed(1)}%). Long calls (> 5 min) have an escalation rate of ${stats.escalationRateByDuration.find((d) => d.category === "Long")?.escalationRate.toFixed(1) || 0}%, suggesting complex issues require supervisor intervention.`} />
        <InsightCard title="Average Success Duration" text={`PTP-captured calls take an average of ${stats.avgDurationByPtpStatus.find((d) => d.ptpStatus === "PTP Captured")?.avgDurationMinutes.toFixed(2) || 0} minutes, indicating that successful resolution requires sustained effort.`} />
        <InsightCard title="Keyword Focus" text={`The top keywords in escalated calls ('payment', 'card', 'credit') confirm that friction is concentrated around financial transaction details and account status.`} />
        <InsightCard title="PTP Capture Rate" text={`Only ${stats.successRate.toFixed(1)}% of total calls result in a PTP. Compare this to the success rate by hour to find the optimal calling window.`} />
        <InsightCard title="Short Call Volume" text={`The highest volume is in the Short category, at ${stats.durationCategoryCounts.Short} calls. This may indicate abandoned attempts or very quick information transfers.`} />
      </div>

      {/* Basic Statistical Analysis (Raw Data) */}
      <h3 style={{ fontWeight: 600, fontSize: 20, marginTop: 32, marginBottom: 16 }}>Basic Statistical Analysis (Raw Data)</h3>
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(280px, 1fr))",
          gap: 18,
          marginBottom: 36,
        }}
      >
        <AnalysisBox title="Success Rate by Hour of Day" data={stats.successRateByHour} />
        <AnalysisBox title="Escalation Rate by Duration Category" data={stats.escalationRateByDuration} />
        <AnalysisBox title="Average Duration by PTP Status" data={stats.avgDurationByPtpStatus} />
      </div>

      {/* Call Summary Keyword Analysis */}
      <h3 style={{ fontWeight: 600, fontSize: 20, marginTop: 32, marginBottom: 16 }}>Call Summary Keyword Analysis</h3>
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "1fr 1fr",
          gap: 20,
          marginBottom: 36
        }}
      >
        <KeywordList title="Top 10 Keywords in ESCALATED Calls" keywords={stats.topKeywordsEscalated} isEscalated={true} />
        <KeywordList title="Top 10 Keywords in NON-ESCALATED Calls" keywords={stats.topKeywordsNonEscalated} isEscalated={false} />
      </div>

      {/* Sample Rows */}
      <h3 style={{ fontWeight: 600, fontSize: 20, marginTop: 28, marginBottom: 8 }}>Sample Rows</h3>
      <div style={{ fontSize: 13, color: "#999", marginBottom: 10 }}>
        Showing the first 5 rows so you can confirm columns look right.
      </div>
      <table
        style={{
          width: "100%",
          borderCollapse: "collapse",
          textAlign: "left",
          color: "white",
          borderRadius: "8px",
          overflow: "hidden",
          background: "#232323",
          marginBottom: 36
        }}
      >
        <thead>
          <tr style={{ backgroundColor: "#353535" }}>
            <th style={{ padding: "10px", fontWeight: 700 }}>customer_id</th>
            <th style={{ padding: "10px", fontWeight: 700 }}>ptp</th>
            <th style={{ padding: "10px", fontWeight: 700 }}>rtp</th>
            <th style={{ padding: "10px", fontWeight: 700 }}>call_duration</th>
            <th style={{ padding: "10px", fontWeight: 700 }}>escalation</th>
            <th style={{ padding: "10px", fontWeight: 700 }}>Minutes</th>
            <th style={{ padding: "10px", fontWeight: 700 }}>Category</th>
          </tr>
        </thead>
        <tbody>
          {rows.slice(0, 5).map((r, idx) => {
            const durationMinutes = hmsToMinutes(r.call_duration);
            const durationCategory = categorizeDuration(durationMinutes);
            return (
              <tr
                key={idx}
                style={{
                  borderBottom: "1px solid #494949",
                  backgroundColor: idx % 2 === 0 ? "#303030" : "#232323",
                }}
              >
                <td style={{ padding: "10px" }}>{r.customer_id}</td>
                <td style={{ padding: "10px" }}>{String(r.ptp)}</td>
                <td style={{ padding: "10px" }}>{String(r.rtp)}</td>
                <td style={{ padding: "10px" }}>{r.call_duration}</td>
                <td style={{ padding: "10px" }}>{String(r.escalation)}</td>
                <td style={{ padding: "10px" }}>{durationMinutes.toFixed(2)}</td>
                <td style={{ padding: "10px" }}>{durationCategory}</td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  </div>
);


}